# Алгоритм кластеризации k-means (k-средних)

**Кластеризация** — задача группировки множества объектов на подмножества (кластеры) таким образом, чтобы объекты из одного кластера были более похожи друг на друга, чем на объекты из других кластеров по какому-либо критерию.

![Clusters](https://user-images.githubusercontent.com/18848039/86250490-5190a800-bbb9-11ea-8718-29309309483d.png)

**Метод k-средних (k-means)** - один из алгоритмов машинного обучения, решающий задачу кластеризации. Данные произвольно разбиваются на кластеры, после чего итеративно перевычисляется центр масс для каждого кластера, полученного на предыдущем шаге, затем векторы разбиваются на кластеры вновь в соответствии с тем, какой из новых центров оказался ближе по выбранной метрике. Цель алгоритма заключается в разделении **n** наблюдений на **k** кластеров таким образом, чтобы каждое наблюдение принадлежало ровно одному кластеру, расположенному на наименьшем расстоянии от наблюдения.

![k-means](https://user-images.githubusercontent.com/18848039/86251509-a254d080-bbba-11ea-8122-2c602a8001cc.jpg)

В каждой итерации **k-means** нам нужен способ найти ближайший центроид к каждому элементу набора данных. Одним из простейших способов вычисления расстояния между двумя векторами признаков является использование евклидова расстояния. Евклидово расстояние между двумя векторами типа [p1, q1] и [p2, q2] равно:

![Euclade_distance2](https://user-images.githubusercontent.com/18848039/86250118-d929e700-bbb8-11ea-8aaf-c4d20a79c40a.PNG)

Шаг 1 – Нужно указать количество кластеров **k**, которые должны быть сгенерированы этим алгоритмом.

Шаг 2 – Случайным образом выберается K точек данных и назначает каждую точку данных кластеру. Проще говоря, классифицировать данные на основе количества точек данных.

Шаг 3 – Теперь алгоритм будет вычислять кластерные центроиды.

Шаг 4 – Далее продолжает повторяться следующее до тех пор, пока мы не найдем оптимальный центроид, который является назначением точек данных кластерам, которые больше не меняются:

   * Сначала будет вычислена сумма квадратов расстояния между точками данных и центроидами.

   * Теперь мы должны назначить каждую точку данных кластеру, который находится ближе, чем другой кластер (центроид).

   * Наконец, вычислияются центроиды для кластеров, взяв среднее значение всех точек данных этого кластера.

#### Визуальное представление работы алгоритма

![K-means_convergence](https://user-images.githubusercontent.com/18848039/86250219-fc549680-bbb8-11ea-972d-ca4e866cfeb9.gif)  

## Работа с программой
Данная программа представляет собой реализацию алгоритма на языке Java.
В файле **/src/main/resources/config.properties** есть следующие свойства:

- **file.name** - имя файла, откуда берутся данные (файл должен находиться в корне проекта)
- **clusters.count** - количество кластеров
- **iterations.max** - максимальное количество итераций

Для примера данных в корне проекта находится файл-датасет **customer_segmentation.csv** 

По умолчанию установлены следующие настройки:
```
file.name=customer_segmentation.csv
clusters.count=3
iterations.max=10
```

Для старта программы - из класса **Main** запустить метод **main**. 

Результат работы программы:
```
------------------------------ CLUSTER -----------------------------------
Centroid {Age=32.565, Education=1.620, Income=29.750, Years Employed=5.974, DebtIncomeRatio=9.998, Other Debt=1.973, Card Debt=0.971}


------------------------------ CLUSTER -----------------------------------
Centroid {Age=45.545, Education=2.5, Income=212.545, Years Employed=20.682, DebtIncomeRatio=8.855, Other Debt=12.0599, Card Debt=5.741}


------------------------------ CLUSTER -----------------------------------
Centroid {Age=40.903, Education=1.885, Income=77.516, Years Employed=14.636, DebtIncomeRatio=10.793, Other Debt=5.281, Card Debt=2.859}
```